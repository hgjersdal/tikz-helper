(in-package :tikz-helper)

(defclass plottingarea ()
  ((width  :initform 05 :initarg :width  :reader width)
   (height :initform 10 :initarg :height :reader height)
   (x-offset  :initform 00 :initarg :x-offset  :reader x-offset)
   (y-offset  :initform 00 :initarg :y-offset  :reader y-offset)
   (plot-x-min :initform 0 :initarg :plot-x-min :reader plot-x-min)
   (plot-x-max :initform 1 :initarg :plot-x-max :reader plot-x-max)
   (plot-y-min :initform 0 :initarg :plot-y-min :reader plot-y-min)
   (plot-y-max :initform 1 :initarg :plot-y-max :reader plot-y-max)
   (ostream :initform t :initarg :stream :accessor ostream))
  (:documentation "Contains output-stream for latex file as well as ingo needed for transformations"))

(defmacro latex-environ ((plottingarea environ &optional (args nil)) &body body)
  "Place tex code generated by body within a latex environment"
  `(progn
     (if ,args
	 (format (ostream ,plottingarea) "\\begin{~a}[~a]~%" ,environ ,args)
	 (format (ostream ,plottingarea) "\\begin{~a}~%" ,environ))
     ,@body
     (format (ostream ,plottingarea) "\\end{~a}~%" ,environ)))

(defun make-transformation (cmax pmin pmax)
  "Makes a linear transformation from data space(pmin-pmax) to figura space 0-cmax"
  (let ((scale (/ (- pmax pmin) cmax)))
    (lambda (x) (/ (- x pmin) scale))))

(defun make-vector-transform (cmax pmin pmax)
  "Same transformation as above, but without translations"
  (let ((scale (/ (- pmax pmin) cmax)))
    (lambda (x) (/ x scale))))

(defmacro scope ((plottingarea &optional (style "")) &body body)
  "Make a tikz scope."
  `(latex-environ (,plottingarea "scope" ,style)
     ,@body))

(defmacro clip ((plottingarea) &body body)
  "Clip a rectangle from origin."
  `(scope (,plottingarea)
     (make-rectangle-path ,plottingarea
			  (x-offset ,plottingarea) (y-offset ,plottingarea)
			  (+ (width ,plottingarea) (x-offset ,plottingarea))
			  (+ (height ,plottingarea) (y-offset ,plottingarea)))
     (path-stroke ,plottingarea nil nil t)
     ,@body))

(defmacro transform-scale ((plottingarea) &body body)
  "Perform transformationf from data coord system to plottingarea system by using scales. Also scales cm, pt, mm etc."
  (let ((x-scale (gensym))
	(y-scale (gensym)))
    `(let ((,x-scale (/  (width ,plottingarea) (- (plot-x-max ,plottingarea) (plot-x-min ,plottingarea))))
	   (,y-scale (/  (height ,plottingarea) (- (plot-y-max ,plottingarea) (plot-y-min ,plottingarea)))))
       (scope (,plottingarea
	       (format nil "shift={(~f,~f)}"
		       (x-offset ,plottingarea)
		       (y-offset ,plottingarea)))
	 (scope (,plottingarea
		 (format nil "shift={(~f,~f)},xscale=~f,yscale=~f"
			 (- (plot-x-min ,plottingarea))
			 (- (plot-y-min ,plottingarea))
			 ,x-scale ,y-scale))
	   ,@body)))))

(defmacro transform ((plottingarea) &body body)
  "Perform transformationf from data coord system to plottingarea system. If this fails, try using transform-scale."
  (let ((x-scale (gensym))
	(y-scale (gensym)))
    `(let ((,x-scale (/  (width ,plottingarea) (- (plot-x-max ,plottingarea) (plot-x-min ,plottingarea))))
	   (,y-scale (/  (height ,plottingarea) (- (plot-y-max ,plottingarea) (plot-y-min ,plottingarea)))))
       (scope (,plottingarea
	       (format nil "shift={(~f,~f)}"
		       (x-offset ,plottingarea)
		       (y-offset ,plottingarea)))
	 (format (ostream ,plottingarea) "\\pgfsetxvec{\\pgfpoint{~fcm}{0cm}}~&" ,x-scale)
	 (format (ostream ,plottingarea) "\\pgfsetyvec{\\pgfpoint{0cm}{~fcm}}~%" ,y-scale)
	 (scope (,plottingarea
		 (format nil "shift={(~f,~f)}"
			 (- (plot-x-min ,plottingarea))
			 (- (plot-y-min ,plottingarea))))
	   ,@body)
	 (format (ostream ,plottingarea) "\\pgfsetxvec{\\pgfpoint{1cm}{0cm}}~&")
	 (format (ostream ,plottingarea) "\\pgfsetyvec{\\pgfpoint{0cm}{1cm}}~%")))))

(defmacro clip-and-transform ((plottingarea) &body body)
  "First clip the plotting area, then perform transformations from data to plottingarea"
  `(clip (,plottingarea)
     (transform (,plottingarea)
       ,@body)))

(defun path-move-to (tikz x y)
  (format (ostream tikz) "\\pgfpathmoveto{ \\pgfpointxy {~f} {~f}}~%" x y))

(defun path-line-to (tikz x y)
  (format (ostream tikz) "\\pgfpathlineto{ \\pgfpointxy {~f} {~f}}~%" x y))

(defun path-stroke (tikz &optional (stroke t) (fill nil) (clip nil))
  "Stroke, fill and or clip the path"
  (let ((action (concatenate 'string
			     (if stroke "stroke," "")
			     (if fill " fill," "")
			     (if clip " clip," ""))))
    (format (ostream tikz) "\\pgfusepath{ ~a }~%" action)))

(defun path-close (tikz)
  "Close the path by connecting first and last point"
  (format (ostream tikz) "\\pgfpathclose~%"))

(defun make-path (tikz x y)
  "Connect data points with straight lines."
  (path-move-to tikz (car x) (car y))
  (mapc (lambda (x y) (path-line-to tikz x y)) (cdr x) (cdr y)))

(defun make-mixed-point (tikz x-data x-unit y-data y-unit)
  "A point in the coord system of the current transformation (x-data, y-data), shifted by another point (x-unit,y-unit).
The other point should be a string with cm, mm, pt or similar invariant unit."
  (format (ostream tikz) "\\pgfpointadd{\\pgfpointxy {~f} {~f}} {\\pgfpoint{~a}{~a}}"
	  x-data y-data x-unit y-unit))

(defun path-move-to-mixed (tikz x-data x-unit y-data y-unit)
  "Move path to mixed point."
  (format (ostream tikz) "\\pgfpathmoveto{ ~a }~%"
	  (make-mixed-point tikz x-data x-unit y-data y-unit)))

(defun path-line-to-mixed (tikz x-data x-unit y-data y-unit)
  "Extend path to mixed point."
  (format (ostream tikz) "\\pgfpathlineto{ ~a }~%"
	  (make-mixed-point tikz x-data x-unit y-data y-unit)))

(defun make-path-mixed-units (tikz x-data x-units y-data y-units)
  "Connect data points with straight lines. Data points are at x-data + x-units, y-data + y-units. Units can be cm,pt,mm, etc"
  (path-move-to-mixed tikz (car x-data) (car x-units) (car y-data) (car y-units))
  (mapc (lambda (x xx y yy) (path-line-to-mixed tikz x xx y yy)) (cdr x-data) (cdr x-units) (cdr y-data) (cdr y-units)))

(defun draw-path (tikz x y style &optional fill)
  "Make a path and draw it."
  (scope (tikz style)
    (make-path tikz x y)
    (path-stroke tikz t fill)))

(defun make-rectangle-path (plottingarea x-min y-min x-max y-max)
  "Make a rectangle path."
  (path-move-to plottingarea x-min y-min)
  (path-line-to plottingarea x-max y-min)
  (path-line-to plottingarea x-max y-max)
  (path-line-to plottingarea x-min y-max)
  (path-close plottingarea))

(defun apply-transform-x (tikz x)
  "Transfor a point to coordinate system of plottingarea"
  (let ((scale (/ (- (plot-x-max tikz) (plot-x-min tikz)) (width tikz))))
    (/ (- x (plot-x-min tikz)) scale)))

(defun apply-transform-y (tikz y)
  "Transfor a point to coordinate system of plottingarea"
  (let ((scale (/ (- (plot-y-max tikz) (plot-y-min tikz)) (height tikz))))
    (/ (- y (plot-y-min tikz)) scale)))

(defun draw-tick-mark (plottingarea numberp precision name style text-style x y xpt+ xpt- ypt+ ypt-)
  "Draw a tick mark on an axis."
  (format (ostream plottingarea)
	  "\\draw[~a] [shift={(~f,~f)}] (~a,~a) -- (~a,~a) node[~a]{ \\scriptsize{"
	  style x y xpt+ ypt+ xpt- ypt- text-style)
  (if numberp
      (format (ostream plottingarea)
	      "\\num[round-mode=places,round-precision=~a]{~a}}};~%"
	      precision name)
      (format (ostream plottingarea) "~a}};~%" name)))

(defun draw-axis-ticks-x (plottingarea x-list &key (names nil) (numberp t) (precision 2)
						(y-shift "0cm") (start "-2pt") (stop "2pt")
						(style "black") (text-style "below"))
  "Draw axis tick marks. Names on the tick marks
names: Text that goes with the tick-mark. Default (nil), is to use the numbers in x-list.
numberp: Is the value a number?
precision: If the name is a number, and floatin point, how many digits should be displayed after '.'.
y-shift: Offset in y. 0 means at plot-y-min. Units like cm,mm,pt can be used.
start: The tick line will start at y-shift + start.
stop: The tick line will stop at y-shift + stop.
style: style of line
text-style: style of text node."
  (scope (plottingarea (format nil "yshift=~a" y-shift))
    (map nil (lambda (x name)
	       (draw-tick-mark plottingarea numberp precision name style text-style x (plot-y-min plottingarea) 0 0 stop start))
	 x-list (if (null names) x-list names))))

(defun draw-axis-ticks-y (plottingarea y-list &key (names nil) (numberp t) (precision 2)
						(x-shift "0cm") (start "-2pt") (stop "2pt")
						(style "black") (text-style "left"))
  "Draw axis tick marks. See draw-axis-tizks-x for details."
  (scope (plottingarea (format nil "xshift=~a" x-shift))
    (map nil (lambda (y name)
	       (draw-tick-mark plottingarea numberp precision name style text-style (plot-x-min plottingarea) y stop start 0 0))
	 y-list (if (null names) y-list names))))

(defun draw-subtick-mark (plottingarea style x y xpt+ xpt- ypt+ ypt-)
  "Draw a tick mark with no text"
  (format (ostream plottingarea)
	  "\\draw[~a] [shift={(~f,~f)}] (~a,~a) -- (~a,~a);~%"
	  style x y xpt+ ypt+ xpt- ypt-))

(defun draw-axis-subticks-x (plottingarea x-list &key (y-shift "0cm") (start "-1pt") (stop "1pt") (style "black"))
  "Draw ticks with no text."
  (scope (plottingarea (format nil "yshift=~a" y-shift))
    (mapc (lambda (x) (draw-subtick-mark plottingarea style x (plot-y-min plottingarea) 0 0 stop start)) x-list)))

(defun draw-axis-subticks-y (plottingarea y-list &key (x-shift "0cm") (start "-1pt") (stop "1pt") (style "black"))
  "Draw ticks with no text"
  (scope (plottingarea (format nil "xshift=~a" x-shift))
    (mapc (lambda (y) (draw-subtick-mark plottingarea style (plot-x-min plottingarea) y stop start 0 0)) y-list)))

(defun draw-plottingarea-rectangle (plottingarea &optional (fill nil) (style "thick,black,fill=white"))
  "Draw a thick square around the ploting area"
  (scope (plottingarea style)
    (make-rectangle-path plottingarea
			 (plot-x-min plottingarea) (plot-y-min plottingarea)
			 (plot-x-max plottingarea) (plot-y-max plottingarea))
    (path-stroke plottingarea t fill)))

(defun draw-axis-cross (plottingarea &optional (style "thick"))
  "Draw axis lines crossing at the origin"
  (draw-line plottingarea (plot-x-min plottingarea) 0 (plot-x-max plottingarea) 0 style)
  (draw-line plottingarea 0 (plot-y-min plottingarea) 0 (plot-y-max plottingarea) style))

(defparameter *tikz-preamble*
"\\documentclass{standalone}
\\ifx\\HCode\\UnDef\\else\\def\\pgfsysdriver{pgfsys-tex4ht.def}\\fi
\\usepackage{tikz}
\\usepackage{color}
\\usepackage{siunitx}
\\usetikzlibrary{arrows,shapes}
")

(defun pdflatex-compile (tex-file)
  "Compile tex-file with pdflatex"
  #+sbcl
  (sb-ext:process-exit-code
   (sb-ext:run-program "pdflatex"
		       (list
			"-output-directory"
			(sb-ext:native-namestring
			 (make-pathname :directory (pathname-directory tex-file)))
			tex-file)
		       :wait t :search t :output *standard-output*))
  #-sbcl (warn "Not implemented"))

(defun pdflatex-compile-view (tex-file &optional (viewer "emacsclient"))
  "Compile file, then view with viewer."
  #+sbcl
  (if (= 0 (pdflatex-compile tex-file))
      (sb-ext:run-program viewer
			  (list (sb-ext:native-namestring
				 (make-pathname :type "pdf" :defaults tex-file)))
			  :wait nil :search t)
      (warn "Process pdflatex failed"))
  #-sbcl
  (warn "Not implemented"))

(defmacro with-tikz-plot ((name filename width height
				plot-x-min plot-x-max
				plot-y-min plot-y-max) &body body)
  "Macro that opens a file, makes a plotting area and opens and closes tikzpicture environment"
  (let ((stream-name (gensym)))
    `(with-open-file (,stream-name ,filename :direction :output :if-exists :supersede)
       (let ((,name (make-instance 'plottingarea :stream ,stream-name :width ,width :height ,height
				   :plot-x-min ,plot-x-min :plot-x-max ,plot-x-max
				   :plot-y-min ,plot-y-min :plot-y-max ,plot-y-max)))
	 (format ,stream-name *tikz-preamble*)
	 (latex-environ (,name "document")
	   (latex-environ (,name "tikzpicture")
	     ,@body))))))

(defmacro with-sugfigure ((plottingarea name
					x-offset y-offset width height
					plot-x-min plot-x-max plot-y-min plot-y-max) &body body)
  "Macro that keeps details of a sub-figure. Used for cliping and transformations."
  `(let ((,name (make-instance 'plottingarea :stream (ostream ,plottingarea)
			       :x-offset ,x-offset :y-offset ,y-offset
			       :width ,width :height ,height
			       :plot-x-min ,plot-x-min :plot-x-max ,plot-x-max
			       :plot-y-min ,plot-y-min :plot-y-max ,plot-y-max)))
     ,@body))

(defun make-range (min stepsize steps)
  "Returns a list with steps elements, where the first is min the next is min+stepsize etc"
  (let ((my-list nil))
    (dotimes (n steps)
      (setf my-list (append my-list (list (+ min (* n stepsize))))))
    my-list))

(defun make-node-string (shape width height &optional (inner-sep 0) (unit "pt"))
  "Make a node string"
  (format nil "~a,inner sep=~f~a,minimum width =~f~a,minimum height=~f~a"
	  shape inner-sep unit width unit height unit))

(defun draw-line (plottingarea x-from y-from x-to y-to style)
  "Generate tikz code to draw a line."
  (format (ostream plottingarea) "\\draw[~a] (~f,~f) -- (~f,~f);~%" style x-from y-from x-to y-to))

(defun draw-text-node (plottingarea x y text style)
  "Generate tikz code to draw a text node."
  (format (ostream plottingarea) "\\node[~a] at (~f,~f) {~a};~%" style x y text))

(defun draw-node (tikz x y style node-string &optional (text ""))
  "Draw a node at point."
  (format (ostream tikz) "\\node at (~f,~f) [~a] {~a}; ~%" x y
	  (concatenate 'string node-string "," style) text))

(defun draw-circle (plottingarea x y style)
  "Generate tikz code to draw a circle."
  (draw-node plottingarea x y style (make-node-string "circle" 3 3)))

(defun draw-rectangle (plottingarea x-from y-from x-to y-to style)
  "Generate tikz code to draw a rectangle."
  (format (ostream plottingarea) "\\draw[~a] (~f,~f) rectangle (~f,~f);~%"
	  style x-from y-from x-to y-to))

(defun draw-profilepoint (plottingarea x y y-error style &optional (node-string (make-node-string "circle" 3 3)))
  "Draw a data-point with error bars in y direction"
  ;;(draw-path plottingarea (list x x) (list (- y y-error) (+ y y-error)) style)
  (scope (plottingarea style)
    (make-path-mixed-units plottingarea
			   (list x x x x x x) (list "-2pt" "2pt" "0pt" "0pt" "-2pt" "2pt")
			   (list (+ y y-error) (+ y y-error) (+ y y-error)
				 (- y y-error) (- y y-error) (- y y-error))
			   (list 0 0 0 0 0 0))
    (path-stroke plottingarea t)
    (draw-node plottingarea x y style node-string)))

(defun draw-profilepoints (plottingarea x y y-error style &optional (node-string (make-node-string "circle" 3 3)))
  (mapcar (lambda (xx yy err) (draw-profilepoint plottingarea xx yy err style node-string))
	  x y y-error))

(defun make-histogram (min bin-size data)
  "A histogram as a simple plist"
  (list :min min :bin-size bin-size :data data))

(defun make-histogram-path-points (histo)
  "Make the path for a histogram, the path here is just a list of points."
  (let* ((y-pos (getf histo :data))
	 (x-pos (make-range (getf histo :min) (getf histo :bin-size) (+ 1 (length y-pos))))
	 (path-x nil)
	 (path-y nil))
    (push (elt x-pos 0) path-x)
    (push 0 path-y)
    (dotimes (i (- (length x-pos) 1))
      (push (elt x-pos i) path-x)
      (push (elt y-pos i) path-y)
      (push (elt x-pos (+ 1 i)) path-x)
      (push (elt y-pos i) path-y))
    (push (elt x-pos (- (length x-pos) 1)) path-x)
    (push 0 path-y)
    (values path-x path-y)))

(defun draw-histogram-horizontal (tikz histo style &optional (fill nil) (separate-bins nil))
  "Draw a histogram."
  (multiple-value-bind (y x) (make-histogram-path-points histo)
    (draw-path tikz x y style fill)
    (when separate-bins
      (mapcar (lambda (x y) (draw-path tikz (list 0 x) (list y y) style nil)) x y))))

(defun draw-histogram (tikz histo style &optional (fill nil) (separate-bins nil))
  "Draw a histogram."
  (multiple-value-bind (x y) (make-histogram-path-points histo)
    (draw-path tikz x y style fill)
    (when separate-bins
      (mapcar (lambda (x y) (draw-path tikz (list x x) (list y 0) style nil)) x y))))

(defun region-of-interest-zoom (top sub style &optional (top-left t) (top-right t) (bottom-left t) (bottom-right t))
  "Draw a rectangle around region of interest, and draw lines connecting it with a sub-figure."
 (scope (top style)
    ;;Region of interest
    (transform (top)
      (make-rectangle-path top (plot-x-min sub) (plot-y-min sub) (plot-x-max sub) (plot-y-max sub)))
    (path-stroke top)
    (format (ostream top) "\\pgfseteorule~%")
    ;;Clipping area, inverted clip of the region of interest and the sub plottingarea
    (transform (sub)
      (make-rectangle-path sub (plot-x-min sub) (plot-y-min sub) (plot-x-max sub) (plot-y-max sub)))
    (transform (top)
      (make-rectangle-path top (plot-x-min sub) (plot-y-min sub) (plot-x-max sub) (plot-y-max sub)))
    (make-rectangle-path top
		  (min 0 (+ (x-offset sub))) (min 0 (+ (y-offset sub)))
		  (max (width top) (+ (x-offset sub) (width sub))) (max (height top) (+ (y-offset sub) (height sub))))
    (path-stroke top nil nil t)
    ;;Draw lines to connect the region of interest and the sub plotting area
    (when bottom-left
      (path-move-to top (apply-transform-x top (plot-x-min sub)) (apply-transform-y top (plot-y-min sub)))
      (path-line-to top (+ (x-offset sub)) (y-offset sub)))
    (when top-left
      (path-move-to top (apply-transform-x top (plot-x-min sub)) (apply-transform-y top (plot-y-max sub)))
      (path-line-to top (+ (x-offset sub)) (+ (y-offset sub) (height sub))))
    (when top-right
      (path-move-to top (apply-transform-x top (plot-x-max sub)) (apply-transform-y top (plot-y-max sub)))
      (path-line-to top (+ (x-offset sub) (width sub)) (+ (y-offset sub) (height sub))))
    (when bottom-right
      (path-move-to top (apply-transform-x top (plot-x-max sub)) (apply-transform-y top (plot-y-min sub)))
      (path-line-to top (+ (x-offset sub) (width sub)) (+ (y-offset sub))))
    (when (or bottom-right bottom-left top-right top-left)
      (path-stroke top))))

(defun draw-datapoints (tikz x y style &optional (node (make-node-string "circle" 3 3)))
  "Draw a set of datapoints"
  (map 'nil (lambda (x y) (draw-node tikz x y style node)) x y))

(defun draw-graph (tikz x y line-style mark-style &optional (node (make-node-string "circle" 3 3)))
  "Draw a graph, with a line connecting datapoints"
  (draw-path tikz x y line-style)
  (draw-datapoints tikz x y mark-style node))

(defun draw-graph-spline (tikz x y line-style mark-style  &optional (node (make-node-string "circle" 3 3)))
  "Draw a graph, with a spline connecting datapoints"
  (let ((n  (min (length x) (length y))))
    (draw-function tikz (tikz-spline:get-spline-fun x y) 100 line-style (elt x 0) (elt x (- n 1))))
  (draw-datapoints tikz x y mark-style node))

(defun draw-function (tikz function samples line-style &optional (x-min nil) (x-max nil))
  "Draw a function y = f(x)"
  (when (null x-min) (setf x-min (plot-x-min tikz)))
  (when (null x-max) (setf x-max (plot-x-max tikz)))
  (let* ((x-vals (make-range x-min (/ (- x-max x-min) samples) (+ 1 samples)))
	 (y-vals (mapcar (lambda (x) (funcall function x)) x-vals)))
    (draw-path tikz x-vals y-vals line-style)))

(defun draw-legend-line (tikz x y width name line-style
			 &optional (mark-style "") (node-string (make-node-string "circle" 3 3))
			   (name-style "") (error-style "") (error-height 0.1))
  "Draw a legent entry for a plot, with a line, and or marks with or without error bars.
For graphs, functions, datapoints, most histograms"
  (if (> (length line-style) 0) (draw-line tikz x y (+ x width) y line-style))
  (if (> (length error-style) 0) (draw-profilepoint tikz (+ (* 0.5 width) x)
						    y error-height error-style))
  (if (> (length mark-style) 0) (draw-node tikz (+ (* 0.5 width) x) y mark-style node-string))
  (draw-text-node tikz (+ x width) y name (concatenate 'string "right," name-style)))

(defun draw-legend-rectangle (tikz x y width height name style name-style)
  "Draw a (filled) rectangle with a legend entry. This is for filled histograms."
  (draw-rectangle tikz x (- y (* 0.5 height))
		  (+ x width) (+ y (* 0.5 height)) style)
  (draw-text-node tikz (+ x width) y name (concatenate 'string "right," name-style)))

(defun draw-legend-rectangles (tikz x y width height names styles &key (x-shift -0.4) (y-shift 0.0))
  "Draw a (filled) rectangle with a legend entry. This is for filled histograms."
  (let ((x (make-range x x-shift (length names)))
	(y (make-range y y-shift (length names))))
    (mapc (lambda (x y name style) (draw-legend-rectangle tikz x y width height name style ""))
	  x y names styles)))

(defun make-histogram2d (x-min x-bin-size x-nbin y-min y-bin-size y-nbin)
  "Alloacte a histogram"
  (let ((data (make-array (list x-nbin y-nbin) :element-type 'double-float)))
    (list :x-min x-min :x-bin-size x-bin-size :x-nbin x-nbin :y-min y-min :y-bin-size y-bin-size :y-nbin y-nbin :data data)))

(defun incf-histo2d (histo x y &optional (val 1.0d0))
  "Increment the histogram bin at x y"
  (let ((x-bin (floor (- x  (getf histo :x-min)) (getf histo :x-bin-size)))
	(y-bin (floor (- y (getf histo :y-min)) (getf histo :y-bin-size))))
    (when (and (>= x-bin 0) (>= y-bin 0)
	       (< x-bin (getf histo :x-nbin)) (< y-bin (getf histo :y-nbin)))
      (incf (aref (getf histo :data) x-bin y-bin) val))))

(defun make-color-combo (z-min z-max val)
  "Make a color somehwere between cold and warm"
  (let ((z% (/ (* 100 (- val z-min)) (- z-max z-min))))
    (cond ((< z% (/ 100 3.0)) (format nil "green!~a!blue"   (max 0 (floor (* 3  z%)))))
	  ((< z% (/ 200 3.0)) (format nil "yellow!~a!green"  (floor (* 3 (- z% 33.3333)))))
	  (t                  (format nil "red!~a!yellow"  (min (floor (* 3 (- z% 66.6666))) 100))))))

(defun draw-histo2d-rectangles (plottingarea histo z-min z-max)
  "Draw a rectangle for each bin. Colors go from cold to hot"
  (let ((x-poses (make-range (getf histo :x-min) (getf histo :x-bin-size) (getf histo :x-nbin)))
	(y-poses (make-range (getf histo :y-min) (getf histo :y-bin-size) (getf histo :y-nbin)))
	(x-bins (make-range 0 1 (getf histo :x-nbin)))
	(y-bins (make-range 0 1 (getf histo :y-nbin))))
    (labels ((draw-bin (x-pos y-pos x-bin y-bin)
	       (scope (plottingarea (make-color-combo z-min z-max (aref (getf histo :data) x-bin y-bin)))
		 (make-rectangle-path plottingarea x-pos y-pos
				      (+ x-pos (getf histo :x-bin-size))
				      (+ y-pos (getf histo :y-bin-size)))
		 (path-stroke plottingarea t t nil)))
	     (draw-row (y-bin y-pos)
	       (map nil (lambda (x-bin x-pos) (draw-bin x-pos y-pos x-bin y-bin)) x-bins x-poses)))
      (map nil #'draw-row y-bins y-poses))))

(defun check-neighbour (x y val data cmap)
  "See if there are borders around the cell. Border means the cell is above val, the neighbour is below."
  (flet ((isbelow (x y)
	   (let ((dim (array-dimensions cmap)))
	     (cond ((or (< x 0) (< y 0)) t)
		   ((or (>= x (first dim)) (>= y (second dim))) t)
		   (t (< (aref data x y) val))))))
    (when (>= (aref data x y) val)
      ;;Vector is left up right below
      (let ((nb (vector (isbelow (- x 1) y) (isbelow x (+ y 1))
			(isbelow (+ x 1) y) (isbelow x (- y 1)))))
	(when (reduce (lambda (x y) (or x y)) nb)
	  (setf (aref cmap x y) nb))))))

(defun make-contour-cells (histo cmap z-val)
  "Count borders for all the cells in histo"
  (let ((data (getf histo :data))
	(xbins (make-range 0 1 (getf histo :x-nbin)))
	(ybins (make-range 0 1 (getf histo :y-nbin))))
    (mapc (lambda (x) (mapc (lambda (y) (check-neighbour x y z-val data cmap)) ybins)) xbins)))

(defun dir-to-num (dir)
  (case dir (:left 0) (:up 1) (:right 2) (:down 3)))

(defun num-to-dir (num)
  (elt (list :left :up :right :down) num))

(defun oposite-dir (dir)
  (let ((num (dir-to-num dir)))
    (num-to-dir (if (> num 1) (- num 2) (+ 2 num)))))

(defun turn-left (dir)
  (let ((num (dir-to-num dir)))
    (num-to-dir (if (= num 0) 3 (- num 1)))))

(defun turn-right (dir)
  (let ((num (dir-to-num dir)))
    (num-to-dir (if (= num 3) 0 (+ num 1)))))

(defun turn-left-xy (dir xy)
  (mapcar #'+ xy
	  (case dir (:left (list -1 -1)) (:up (list -1 1))
		(:right (list 1 1)) (:down (list 1 -1)))))

(defun continue-xy (dir xy)
  (mapcar #'+ xy
	  (case dir (:left  (list -1 0)) (:up    (list 0 1))
		(:right (list 1 0)) (:down  (list 0 -1)))))

(defun borderp (xy borderdir cmap)
  "Does cell xy have a border in direction borderdir?"
  (let ((dim (array-dimensions cmap)))
    (cond ((minusp (elt xy 0)) nil)
	  ((minusp (elt xy 1)) nil)
	  ((>= (elt xy 0) (elt dim 0)) nil)
	  ((>= (elt xy 1) (elt dim 1)) nil)
	  ((null (aref cmap (first xy) (second  xy))) nil)
	  ((aref (aref cmap (first xy) (second  xy)) (dir-to-num borderdir)) t))))

(defun border-correction (max-bin min-bin val)
  "Linear interpolation"
  (if (= max-bin min-bin) 0.0
      (- (/ (- val min-bin) (- max-bin min-bin))  0.5d0)))

(defun move-to-border (xy dir histo val)
  "Which side of the cell should the contour line be on? Positions are corrected with a linear interpolation."
  (flet ((get-correction (xy x-shift y-shift)
	   (let ((dim (array-dimensions (getf histo :data))))
	     (if (or (minusp (+ x-shift (first xy))) (minusp (+ y-shift (second xy)))
		     (>= (+ x-shift (first xy)) (elt dim 0)) (>= (+ y-shift (second xy)) (elt dim 1))
		     (<= val 0)) 
		 0.0
		 (border-correction (aref (getf histo :data) (first xy) (second xy))
				    (aref (getf histo :data) (+ x-shift (first xy)) (+ y-shift (second xy)))
				    val)))))
    (mapcar #'+ xy (case dir
		     (:left (list (get-correction xy -1 0) 0.5))
		     (:up (list 0.5 (- 1.0 (get-correction xy 0 1))))
		     (:right (list (- 1.0 (get-correction xy 1 0)) 0.5))
		     (:down (list 0.5 (get-correction xy 0 -1)))))))

(defun add-contour-path-point (xy dir histo tikz val)
  "Add a contour point to path,"
  (let* ((xy (move-to-border xy dir histo val))
	 (x (+ (getf histo :x-min) (* (elt xy 0) (getf histo :x-bin-size))))
	 (y (+ (getf histo :y-min) (* (elt xy 1) (getf histo :y-bin-size)))))
    (path-line-to tikz x y)))

(defun continue-path (xy dir cmap histo tikz val)
  "Stroll along path with border at left hand side."
  (let ((borderdir (turn-left dir)))
    (setf (aref (aref cmap (first xy) (second xy)) (dir-to-num borderdir)) nil)
    (add-contour-path-point xy borderdir histo tikz val))
  (cond ((borderp (turn-left-xy dir xy) (oposite-dir dir) cmap)
	 (continue-path (turn-left-xy dir xy) (turn-left dir) cmap histo tikz val))
	((borderp (continue-xy dir xy) (turn-left dir) cmap)
	 (continue-path (continue-xy dir xy) dir cmap histo tikz val))
	((borderp xy dir cmap)
	 (continue-path xy (turn-right dir) cmap histo tikz val))))

(defun start-contour-line (x y cmap histo tikz val)
  "Start the contour line, if cell has borders."
  (let ((cell (aref cmap x y)))
    (unless (or (null cell) (reduce (lambda (x y) (and (not x) (not y))) cell))
      (let* ((dir (num-to-dir 
		   (cond ((aref cell 0) 0) ((aref cell 1) 1) ((aref cell 2) 2) ((aref cell 3) 3))))
	     (xy (move-to-border (list x y) dir histo val))
	     (xx (+ (getf histo :x-min) (* (first xy) (getf histo :x-bin-size))))
	     (yy (+ (getf histo :y-min) (* (second xy) (getf histo :y-bin-size)))))
	(path-move-to tikz xx yy)
	(continue-path (list x y) (turn-right dir) cmap histo tikz val)
	(path-close tikz)))))

(defun draw-histo2d-contour (plottingarea histo z-min z-max nlines fillp)
  "Draw possibly filled contour lines."
  (let ((cmap (make-array (list (getf histo :x-nbin) (getf histo :y-nbin)) :initial-element nil))
	(data (getf histo :data))
	(xbins (make-range 0 1 (getf histo :x-nbin)))
	(ybins (make-range 0 1 (getf histo :y-nbin))))
    (dotimes (i nlines)
      (let ((height (+ z-min (* i (/ (- z-max z-min) nlines)))))
	(mapc (lambda (x) (mapc (lambda (y) (check-neighbour x y height data cmap)) ybins)) xbins)
	(scope (plottingarea (format nil "draw=black,fill=~a" (make-color-combo z-min z-max height)))
	  (mapc (lambda (x) (mapc (lambda (y) (start-contour-line x y cmap histo plottingarea height)) ybins)) xbins)
	  (path-stroke plottingarea t fillp))))))
  
